# -*- coding:utf-8 -*-
# 正则表达式学习笔记
<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html> <!--<![endif]-->

<html>
<body>

<h1>数据获取--听课笔记</h1>
<p>作者: renji</p>
<img width="100px" height="100px"src="./myNameCard.jpg">
<h1>数据获取--正则表达式</h1>

<p> 正则表达式是对字符串的操作的一种逻辑公式，就是用事先定义好的一些特殊字符、及这些特殊字符的组合，
    组成一个“有规则的字符串”，</br>这个“有规则的字符串”用来表达对字符串的一种过滤逻辑。
</p>
<p>在实际爬虫解析中，经常是把dom和正则表达式结合起来运用，正则表达式用于字符串特征比较明显的情况，</br>
    但是同样的正则表达式可能在html中出现过多次，</br>而在dom中可以选择class和id 来精确的找到dom模块，从小缩小查找范围
</p>
<h2>正则表达式的规则</h2>    
<p>
    <table border="2">
    <tr>
    <th>匹配规则</th>
    <th>说明释义</th>
    </tr>

    <tr>
    <td>\</td>
    <td>转义符，如\?</td>
    </tr>

    <tr>
    <td>^</td>
    <td>字符串的开始</td>
    </tr>

    <tr>
    <td>$</td>
    <td>字符串的结束</td>
    </tr>

    <tr>
    <td>*</td>
    <td>匹配前面几个子表达式0次或多次</td>
    </tr>

    <tr>
    <td>+</td>
    <td>匹配前面几个子表达式0次或多次</td>
    </tr>

    <tr>
    <td>?</td>
    <td>匹配前面几个子表达式0次或1次</td>
    </tr>

    <tr>
    <td>{n,m}</td>
    <td>匹配至少n次，最多m次</td>
    </tr>

    <tr>
    <td>.</td>
    <td>匹配除\n之外的单个字符</td>
    </tr>

    <tr>
    <td>(pattern)</td>
    <td>匹配并获取这个匹配，</td>
    </tr>

    <tr>
    <td>[xyz]</td>
    <td>字符集合，匹配任何集合里的字符</td>
    </tr>

    <tr>
    <td>[^xyz]</td>
    <td>排除字符中的字符，不能匹配</td>
    </tr>

    <tr>
    <td>\d</td>
    <td>匹配一个数字，等价[0,9]</td>
    </tr>
</table>
</p>
<p>
以上的 {n,m}表示匹配至少n次，最多m次；</br>
其中 ？ = {0，1}、 * = {0,∞} 、 + ={1，∞}
</p>
<p>=======================================================================</p>
<p>实战代码部分演示</p>
<p>
        # http=' href="http://www.baidu.com">'</br>
        # print(re.findall('href=\".*\"',http))       #匹配内链地址 </br>
        # print(re.findall('href=\"(.*?)\"',http))[0]   #小括号表示匹配搜索结果中展示出来。</br>
        
        # print(re.findall('[a-z,A-Z,0-9]',s2))       #利用集合的方式匹配所有字母</br>
        # print(re.findall('[a-z,A-Z,0-9]+',s2))      #匹配显示所有单词</br>
        # print(re.findall('[^0-9]+',s2))           #这里的尖括号表示匹配 非0-9的值</br>
</p>

<h2>
    贪婪模式与非贪婪模式
</h2>
<p>
贪婪模式：</br>
    ？该字符紧跟任何一个其他限制符（*，+，？，{n,m}） 后面时，匹配模式是贪婪的。</br>
非贪婪模式：</br>
    尽可能少的匹配所搜索的字符串。</br>
默认贪婪模式则尽可能多的匹配所搜索的字符串</br>

</p>
<h2>sub 替换模式</h2>
<p>
    sub 的格式：</br>
    (?<=(pattern)) sub ( ?=pattern)</br>  
    前限定规则，sub，后限定规则。
    re.sub("(?<= id= 'title'>).*?(?=<)”,'戊戌变法'，c文件名)</br>
    总结小括号的作用：</br>
    () 括号内的内容作为返回</br>
    (?<=)  (?=)   前限定规则，sub，后限定规则。</br>   
</p>
<h2> Match & Compile 方法</h2>
<p>
    compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象，是全局匹配函数</br>
    match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none</br>
</p>
<p style='color: #ff0000',size =5;> 
特别注意：(full)match 函数match（）只有在0位置匹配成功的话才有返回，如果不是开始位置匹配的话，match()就返回none</br>
<p>
    search函数：扫描整个字符串并返回第一个成功的匹配,否则返回none。</br>   
</p>

<h1>数据获取---dom操作</h1>
<p>
    DOM 是document object model 缩称。</br>
    这一块主要是讲dom操作器Xpath.</br>
</p>
<p>
    Xpath的语法见下图：</br>
    <table border="3">
        <tr>
            <th>表达式</th>
            <th>描述</th>
        </tr>
        <tr>
            <td>nodename</td>
            <td>选取此节点的所有子节点，tag或*选择任意的tag</td>
        </tr>
        <tr>
            <td>/</td>
            <td>从根节点选取，选择直接子节点，不包括更小的后代（孙节点，从孙节点。。）</td>
        </tr>
        <tr>
            <td>//</td>
            <td>从当前路径选取文档的节点，而不考虑他们的位置，包含所有的后代</td>
        </tr>
        <tr>
            <td>.</td>
            <td>选取当前节点</td>
        </tr>
        <tr>
            <td>..</td>
            <td>选取当前节点的父节点</td>
        </tr>
        <tr>
            <td>@</td>
            <td>选取属性</td>
        </tr>
</p>
</body>
</html>